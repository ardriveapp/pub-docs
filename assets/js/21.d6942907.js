(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{294:function(e,t,i){"use strict";i.r(t);var r=i(14),a=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"read-arfs-data"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#read-arfs-data"}},[e._v("#")]),e._v(" Read ArFS Data")]),e._v(" "),t("p",[e._v("Clients can perform read operations to create a timeline of entity write transactions which can then be replayed to construct the Drive state.  This is done by querying an Arweave GraphQL index for the user’s respective transactions. "),t("a",{attrs:{href:"https://gql-guide.vercel.app/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Arweave GraphQL Guide"),t("OutboundLink")],1),e._v(" can provide more information on how to use Arweave GraphQL.  If no GraphQL index is available, drive state can only be generated by downloading and inspecting all transactions made by the user’s wallet")]),e._v(" "),t("p",[e._v("This timeline of transactions should be grouped by the block number of each transaction. At every step of the timeline, the client can check if the entity was written by an authorized user. This also conveniently enables the client to surface a trusted entity version history to the user.")]),e._v(" "),t("p",[e._v("To determine the owner of a Drive, clients must check for who created the first Drive Entity transaction using that "),t("code",[e._v("Drive-Id")]),e._v(".  Until a trusted permissions or ACL system is put in place, any transaction in a drive created by any wallet other than the one who created the first Drive Entity transaction could be considered spam.")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("Unix-Time")]),e._v(" defined on each transaction should be reserved for tie-breaking same entity updates in the same block and should not be trusted as the source of truth for entity write ordering. This is unimportant for single owner drives but is crucial for multi-owner drives with updateable permissions (currently undefined in this spec) as a malicious user could fake the "),t("code",[e._v("Unix-Time")]),e._v(" to modify the drive timeline for other users.")]),e._v(" "),t("ul",[t("li",[e._v("Drives that have been updated many times can have a long entity timeline which can be a performance bottleneck. To avoid this, clients can cache the drive state locally and sync updates to the file system by only querying for entities in blocks higher than the last time they checked.")]),e._v(" "),t("li",[e._v("Not checking for Drive Ownership could result in seeing incorrect drive state and GraphQL queries.")])]),e._v(" "),t("h2",{attrs:{id:"folder-file-paths"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#folder-file-paths"}},[e._v("#")]),e._v(" Folder/File Paths")]),e._v(" "),t("p",[e._v("ArweaveFS does not store folder or file paths along with entities as these paths will need to be updated whenever the parent folder name changes which can require many updates for deeply nested file systems. Instead, folder/file paths are left for the client to generate from the folder/file names.")]),e._v(" "),t("h2",{attrs:{id:"folder-view-queries"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#folder-view-queries"}},[e._v("#")]),e._v(" Folder View Queries")]),e._v(" "),t("p",[e._v("Clients that want to provide users with a quick view of a single folder can simply query for an entity timeline for a particular folder by its id. Clients with multi-owner permissions will additionally have to query for the folder's parent drive entity for permission based filtering of the timeline.")])])}),[],!1,null,null,null);t.default=a.exports}}]);